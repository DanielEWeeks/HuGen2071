---
webr:
  packages: ['tidyverse','tidylog']
editor: 
  mode: source  
---

# R Merging Exercise

```{r,echo=FALSE,message=FALSE,warning=FALSE}
require(knitr)
# Set so that long lines in R will be wrapped:
opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=TRUE)
```

## Merging Best Practice

- *Always* be careful when merging.              
- **Always check for duplicated IDs** before doing the merge.     
- Always check that your ID columns do not contain any missing values. 
- Check that the values in the ID columns (e.g., the keys) match.      
    - Can use an `anti_join` to check this.                               
- Inconsistencies in the values of the keys can be hard to fix.        
- **Always check the dimensions**, before and after the merge, to make sure the 
merged object has the expected number of rows and columns.             
- Always explicitly name the keys you are merging on.
- When using tidyverse `join` commands, load the `tidylog` R package in order to turn on very useful additional feedback. 


## Load Libraries

```{webr-r}
library(tidyverse)
library(tidylog)
```

## Input data

Let's load the synthetic simulated Project 1 data and associated data dictionary:

```{webr-r}
# Download file within the WebR environment
root_srcfile <- "https://raw.githubusercontent.com/DanielEWeeks/HuGen2071/main/"
download.file(paste0(root_srcfile,"data/project1.RData"),
              "project1.RData")
load("project1.RData", verbose = TRUE)
dim(ds)
dim(dd)
```

## Select a subset of subject-level fields

Set up a data frame `a` that has these subject-level fields: "subject_id" "maternal_age_delivery" "case_control_status" "prepregnancy_BMI"

```{webr-r}
a <- ds %>% 
  select("subject_id", 
         "maternal_age_delivery", 
         "case_control_status", 
         "prepregnancy_BMI") %>% 
  arrange(subject_id)
dim(a)
head(a,10)
tail(a)
```

## Unique records

The data were given to us in a way that repeated subject-level information, once for each sample from each individual subject.

From your data frame `a` select only the unique records, creating data frame `b`.

::: {.callout-tip collapse="true"}
Use the `unique` command from base R or the `distinct` command from the `dplyr` R package.
:::

```{webr-r}
# Edit/add/try out R code here
```



::: {.callout-tip collapse="true"}
## Expand to see solution

```{webr-r}
dim(a)
b <- unique(a)
dim(b)
head(b)

b1 <- a %>% distinct()
dim(b1)

all.equal(b,b1)
all.equal(b,b1, check.attributes=FALSE)
head(rownames(b))
head(rownames(b1))
# Reset row names
rownames(b) <- NULL
rownames(b1) <- NULL
all.equal(b,b1)
```

### Comment

It is better to apply `unique` to the whole data frame, not just to the `subject_id` column, as that ensures that you are selecting whole records that are unique across all of their columns.

Note that the `dplyr` R package provides the `distinct` command, which keeps only unique/distinct rows from a data frame.  It is faster than the `unique` command.

```{webr-r}
(ex1 <- data.frame(ID=c(1,1,1,2),trait=c(10, 9, 9, 11)))
unique(ex1)

ex1 %>% distinct()
```
:::

## Check that the `subject_id`'s are now not duplicated

Are the `subject_id`'s unique?

Hint: In the `R Recoding Reshaping Exercise` you learned how to check for duplicated values in a vector.  Use that knowledge here.


```{webr-r}
# Edit/add/try out R code here
```



::: {.callout-tip collapse="true"}
## Expand to see solution

```{webr-r}
sum(duplicated(b$subject_id))
b %>% 
  group_by(subject_id) %>% 
  filter(n()>1)
```
:::

## Create random integer IDs

Create a new column `ID` containing randomly chosen integer IDs; this is necessary to de-identify the data. To do this, use the `sample` command, sampling integers from 1 to the number of rows in data frame `b`.


```{webr-r}
# Edit/add/try out R code here
```



::: {.callout-tip collapse="true"}
## Expand to see solution

```{webr-r}
set.seed(10234)
b$ID <- sample(c(1:nrow(b)), replace = FALSE)
head(b %>% select(subject_id, ID))
sum(duplicated(b$ID))
```

This could also be done using the `sample-int()` function:

```{webr-r}
b <- b %>% mutate(ID=sample.int(nrow(.)))
head(b %>% select(subject_id, ID))
sum(duplicated(b$ID))
```

:::



## Merging Best Practice

Always be careful when merging.

-   *Always check for duplicated IDs* before doing the merge.
-   Always check that your ID columns do not contain any missing values.
-   Check that the values in the ID columns (e.g., the keys) match.
    -   Can use an 'anti_join' to check this.
    -   Inconsistencies in the values of the keys can be hard to fix.
-   *Always check the dimensions* to make sure the merged object has the expected number of rows and columns.
-   Always explicitly name the keys you are merging on.
    -   If you don't name them, then the join command will use all variables in common across `x` and `y`.
- When using tidyverse `join` commands, load the `tidylog` R package in order to turn on very useful additional feedback.     

## Tidyverse `join` commands  

Here is a nice illustration of joins from RStudio (which they shared under a CC_BY 4.0 license):

![](img/JoinCheetSheetRStudio.png)

 

To illustrate the join commands, let's set up these data frames `a` 
and `b`: 

```{webr-r}                                                           
(a <- data.frame(id=c(1:3),a=rep(1,3)))                               
(b <- data.frame(id=c(1,2,4),b=rep(2,3)))                             
```                                                                   


The `left_join(a,b)` command from the 'tidyverse' package keeps all observations in a, joining in matching rows from b.    

```{webr-r}   
(d <- cbind(a, "    " ,b)) 
left_join(a, b, join_by(id))                                               
```         


The `right_join(a,b)` command keeps all observations in b, joining in matching rows from a.  

```{webr-r}                                                              
d
right_join(a, b, join_by(id))                                                
```     

 

The `full_join(a,b)` command keeps all observations in a and b. 

```{webr-r}                                                            
d
full_join(a, b, join_by(id))                                               
```                                                                    



The `inner_join(a,b)` command only keeps observations from a that have a matching key in b.

```{webr-r}   
(d <- cbind(a, "    " ,b)) 
inner_join(a, b, join_by(id))                                               
```         

    

To illustrate how to handle different names for the common ID field, let's set up these data frames a and b slightly differently:                                          
```{webr-r}                                                                
(a <- data.frame(ID1=c(3:1),a=rep(1,3)))                                 
(b <- data.frame(id=c(1,2,4),b=rep(2,3)))                                
```                                                                      



```{webr-r}                                                          
(d <- cbind(a, "    " ,b))                    
full_join(a, b, join_by(ID1 == id))                                      
```                                                                  



What if one data frame has non-unique IDs?  

```{webr-r}                                                            
(a <- data.frame(id=c(3:1),a=c('a3','a2','a1')))                     
(b <- data.frame(id=c(2,2,4),b=c('b1','b2','b3')))                 
```                                                                  

    

merge: non-unique IDs in data frame b. A one-to-many relationship.  

```{webr-r}                                                             
(d <- cbind(a, "    " ,b))                                                  
full_join(a,b, join_by(id))
```                                                                     
So data frame `a` originally had 3 records, but now the full join outputs 
a 5 record data frame.                                                

     

merge: non-unique IDs in both data frames a and b. All possible combinations. 

```{webr-r}                                                                     
a <- data.frame(id=c(2,2,1),a=c('a3','a2','a1'))                              
cbind(a, "    " ,b)                                                                
```                                                                             



```{webr-r}
left_join(a, b, join_by(id))   
```




A filtering `semi_join(a,b)` returns all rows from a that have a match in 
b                                                                   
```{webr-r}                                                          
cbind(a, "    " ,b)                                                      
semi_join(a, b, join_by(id))                                              
```                                                                   

  

A filtering `anti_join(a,b)` returns all rows from a that do not have a match in b. Useful for understanding causes of mismatches when joining. 

```{webr-r}                                                              
cbind(a, "    " ,b)                                                          
anti_join(a, b, join_by(id))                                                  
```                                                                       

                                   

In 'R for Data Science', the authors argue that using tidyverse-style commands (e.g., `left_join`) is better than using the `merge` command of base R because 

> "they more clearly convey the intent of your code: the difference between the joins is really important but concealed in the arguments of `merge()`. dplyr’s joins are considerably faster and don’t mess with the order of the rows."

See <http://r4ds.had.co.nz/relational-data.html#other-implementations>

## Merge in new phenotype information

The PI has sent you new trait data for your subjects.

```{webr-r}
# Download file within the WebR environment
root_srcfile <- "https://raw.githubusercontent.com/DanielEWeeks/HuGen2071/main/"
download.file(paste0(root_srcfile,"data/project1.RData"),
              "project1.RData")
download.file(paste0(root_srcfile,"data/newtrait.tsv"),
              "newtrait.tsv")
new <- read_tsv("newtrait.tsv")
head(new)
dim(new)
load("project1.RData", verbose = TRUE)
b <-  ds %>% 
  select("subject_id", 
         "maternal_age_delivery", 
         "case_control_status", 
         "prepregnancy_BMI") %>% 
  distinct()
dim(b)
```

Carefully merge in the new data in using tidyverse commands. As this is subject-level information, it should be merged into the subject-level data frame `b` which was created above when from your data frame `a` you selected only the unique records. Following recommended best merging practice, be sure to: 

- Check for duplicated IDs before doing the merge.     
- Check that your ID columns do not contain any missing values. 
- Check that the values in the ID columns (e.g., the keys) match.      
- Check the dimensions before and after the merge, to make sure the 
merged object has the expected number of rows and columns.             
- Explicitly name the keys you are merging on.

If you notice any problems with this merge, prepare a report for the PI detailing what you noticed and what you'd like to ask the PI about.


```{webr-r}
# Edit/add/try out R code here
```



::: {.callout-tip collapse="true"}
## Expand to see solution

Here we load the `tidylog` R package, which will result in useful feedback when tidyverse commands are executed.  

```{webr-r}
# Load 'tidylog' 
library(tidylog)
# Check for duplicated IDs
sum(duplicated(b$subject_id))
sum(duplicated(new$subject_id))
```

Which `subject_id`'s are duplicated?

```{webr-r}
new %>% 
  group_by(subject_id) %>% 
  mutate(n=n()) %>% 
  filter(n>1)
```

Now check if there are any missing values in the ID columns?

```{webr-r}
sum(is.na(b$subject_id))
sum(is.na(new$subject_id))
```

How many of rows would you expect the merged data frame to have?

```{webr-r}
# Check the dimensions
dim(b)
dim(new)
b2 <- left_join(b, new, by="subject_id")
dim(b2)
head(b2)
b3 <- full_join(b, new, by="subject_id")
dim(b3)
```

Why did the number of rows increase when doing the full join?  

:::

## Further checks

When merging data based on an ID shared in common, it is not only important to check for duplicated IDs, but it is also important to check for overlap of the two ID sets.

Check if the set of `subject_id` IDs in your dataframe `b` fully overlaps the set of `subject_id` IDs in the `new` data set.  If there is not full overlap, document which IDs do not overlap. 

Hint: Use an `anti_join`.

```{webr-r}
# Edit/add/try out R code here
```


::: {.callout-tip collapse="true"}
## Expand to see solution
`anti_join()` return all rows from x without a match in y.

```{webr-r}
# Tally how many of b's subject_id's are in new
table(b$subject_id %in% new$subject_id)
# Tally how many of new's subject_id's are in b
table(new$subject_id %in% b$subject_id)
# List the b's subject_id's that are not in new
b$subject_id[!(b$subject_id %in% new$subject_id)]
# List the new's subject_id's that are not in b
new$subject_id[!(new$subject_id %in% b$subject_id)]

# Simpler to do this with anti_join's
anti_join(b, new, by="subject_id")
anti_join(new, b, by="subject_id")
```
:::

## Letter to the PI

Prepare a brief letter to the PI describing the problems in the data that you discovered when trying to merge in the new trait data.  

::: {.callout-tip collapse="true"}
## Expand to see solution

Dear Dr. PI,

When trying to merge in the new trait data that you sent, I noticed a few issues that I wanted to bring to your attention.

The new data set has a duplicated record for `subject_id` SUBJ09.  

The new data set has a `subject_id` that is not observed in our original data set: SUBJ00

The new data set is missing records for these two `subject_id`'s that are observed in our original data set: SUBJ18 and SUBJ24.

Please resolve these issues and send us a corrected version of the new trait data.

Thank you!
:::
